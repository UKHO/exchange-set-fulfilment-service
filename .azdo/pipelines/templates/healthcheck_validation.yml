# Health check validation YAML for post-deployment
parameters:
# The name of the service connection for deployment.
- name: AzureSubscription
  type: string
# The base URL for the deployed application (if known)
- name: AppBaseUrl
  type: string
  default: ""
# The Azure environment name for dynamic URL construction
- name: AzureEnvName
  type: string
  default: "$(AZURE_ENV_NAME)"
# Timeout in minutes for health check (inspired by your PS1 script)
- name: HealthCheckTimeoutMinutes
  type: number
  default: 5
# Sleep time between retries in seconds
- name: SleepTimeSeconds
  type: number
  default: 10
# Continue on error flag
- name: OnErrorContinue
  type: boolean
  default: false

steps:
- task: AzureCLI@2
  displayName: 'Health Check Validation'
  inputs:
    azureSubscription: ${{ parameters.AzureSubscription }}
    scriptType: bash
    scriptLocation: inlineScript
    inlineScript: |
      echo "Starting health check validation for EFS Orchestrator"
      
      # Determine the base URL - either from parameter or construct dynamically
      if [ -n "${{ parameters.AppBaseUrl }}" ] && [ "${{ parameters.AppBaseUrl }}" != "" ]; then
        BASE_URL="${{ parameters.AppBaseUrl }}"
        echo "Using provided base URL: $BASE_URL"
      else
        # Construct URL from Azure environment
        ENV_NAME="${{ parameters.AzureEnvName }}"
        if [ -z "$ENV_NAME" ]; then
          ENV_NAME="$AZURE_ENV_NAME"
        fi
        
        # Get Container App Environment Domain from AZD
        echo "Reading azd variables to get container app domain..."
        while IFS='=' read -r key value; do
            value=$(echo "$value" | sed 's/^"//' | sed 's/"$//')
            export "$key=$value"
        done <<EOF
        $(azd env get-values)
        EOF
        
        if [ -n "$AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN" ]; then
          BASE_URL="https://efs-orchestrator--$ENV_NAME.$AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN"
          echo "Constructed base URL: $BASE_URL"
        else
          echo "? Could not determine container app domain. Please provide AppBaseUrl parameter."
          exit 1
        fi
      fi
      
      # Function to perform health check with timeout (inspired by your PS1 script)
      perform_health_check_with_timeout() {
        local url=$1
        local endpoint=$2
        local timeout_minutes=${{ parameters.HealthCheckTimeoutMinutes }}
        local sleep_seconds=${{ parameters.SleepTimeSeconds }}
        local full_url="${url}${endpoint}"
        
        echo "Polling URL: $full_url (timeout: ${timeout_minutes}min, sleep: ${sleep_seconds}s)"
        
        local timeout_seconds=$((timeout_minutes * 60))
        local elapsed_seconds=0
        local is_healthy="false"
        
        while [ $elapsed_seconds -lt $timeout_seconds ]; do
          echo "Health check attempt at ${elapsed_seconds}s/${timeout_seconds}s for $endpoint"
          
          response=$(curl -s -w "HTTPSTATUS:%{http_code}" --max-time 30 "$full_url" 2>/dev/null || echo "HTTPSTATUS:000")
          http_code=$(echo $response | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          body=$(echo $response | sed -e 's/HTTPSTATUS\:.*//g')
          
          echo "HTTP Status: $http_code"
          
          if [ "$http_code" -eq 200 ]; then
            echo "? Service is up. Stopping polling for $endpoint"
            is_healthy="true"
            break
          else
            echo "? Service not yet up. Status code: $http_code. Re-checking after ${sleep_seconds}s..."
          fi
          
          sleep $sleep_seconds
          elapsed_seconds=$((elapsed_seconds + sleep_seconds))
        done
        
        if [ "$is_healthy" = "true" ]; then
          echo "? Health check passed for $endpoint"
          return 0
        else
          echo "? Service was not up in ${timeout_minutes} minutes for $endpoint"
          return 1
        fi
      }
      
      # Main health check execution (inspired by your PS1 approach)
      HEALTH_CHECK_FAILED=false
      EFS_HEALTH_STATUS="false"
      FSS_HEALTH_STATUS="false"
      SCS_HEALTH_STATUS="false"
      
      # Check main health endpoint
      echo "=== EFS Orchestrator Health Check ==="
      if perform_health_check_with_timeout "$BASE_URL" "/health"; then
        EFS_HEALTH_STATUS="true"
      else
        HEALTH_CHECK_FAILED=true
      fi
      
      # Check liveness endpoint
      echo "=== EFS Orchestrator Alive Check ==="
      if perform_health_check_with_timeout "$BASE_URL" "/alive"; then
        echo "EFS liveness check passed"
      else
        HEALTH_CHECK_FAILED=true
      fi
      
      # Check dependent services if URLs are provided
      if [ ! -z "${FSS_ENDPOINT_HEALTH:-}" ]; then
        echo "=== FSS Dependency Health Check ==="
        if perform_health_check_with_timeout "$FSS_ENDPOINT_HEALTH" ""; then
          FSS_HEALTH_STATUS="true"
        else
          HEALTH_CHECK_FAILED=true
        fi
      else
        echo "FSS_ENDPOINT_HEALTH not configured, skipping FSS health check"
        FSS_HEALTH_STATUS="not_configured"
      fi
      
      # Check SCS service if URL is provided
      if [ ! -z "${SCS_ENDPOINT_HEALTH:-}" ]; then
        echo "=== SCS Dependency Health Check ==="
        if perform_health_check_with_timeout "$SCS_ENDPOINT_HEALTH" ""; then
          SCS_HEALTH_STATUS="true"
        else
          HEALTH_CHECK_FAILED=true
        fi
      else
        echo "SCS_ENDPOINT_HEALTH not configured, skipping SCS health check"
        SCS_HEALTH_STATUS="not_configured"
      fi
      
      # Set pipeline variables (like your PS1 script)
      echo "##vso[task.setvariable variable=EFS_IS_HEALTHY]$EFS_HEALTH_STATUS"
      echo "##vso[task.setvariable variable=FSS_IS_HEALTHY]$FSS_HEALTH_STATUS"
      echo "##vso[task.setvariable variable=SCS_IS_HEALTHY]$SCS_HEALTH_STATUS"
      echo "##vso[task.setvariable variable=ALL_SERVICES_HEALTHY]$([ "$HEALTH_CHECK_FAILED" = false ] && echo "true" || echo "false")"
      
      # Final result (with your PS1 error handling approach)
      if [ "$HEALTH_CHECK_FAILED" = true ]; then
        echo ""
        echo "? One or more health checks failed. Deployment validation unsuccessful."
        echo "   EFS Health: $EFS_HEALTH_STATUS"
        echo "   FSS Health: $FSS_HEALTH_STATUS"
        echo "   SCS Health: $SCS_HEALTH_STATUS"
        echo "   Please check the application logs and ensure all services are running correctly."
        
        # Handle error continuation like your PS1 script
        if [ "${{ parameters.OnErrorContinue }}" = "true" ]; then
          echo "??  OnErrorContinue=true, pipeline will continue despite health check failures"
          exit 0
        else
          echo "? OnErrorContinue=false, failing the pipeline"
          exit 1
        fi
      else
        echo ""
        echo "? All health checks passed. Deployment validation successful."
        echo "   EFS Health: $EFS_HEALTH_STATUS"
        echo "   FSS Health: $FSS_HEALTH_STATUS"
        echo "   SCS Health: $SCS_HEALTH_STATUS"
        echo "   EFS Orchestrator and dependencies are ready to accept traffic."
        exit 0
      fi
  env:
    AZURE_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
    AZURE_ENV_NAME: $(AZURE_ENV_NAME)
    AZURE_LOCATION: $(AZURE_LOCATION)
    FSS_ENDPOINT_HEALTH: $(FSS_ENDPOINT_HEALTH)
    SCS_ENDPOINT_HEALTH: $(SCS_ENDPOINT_HEALTH)
