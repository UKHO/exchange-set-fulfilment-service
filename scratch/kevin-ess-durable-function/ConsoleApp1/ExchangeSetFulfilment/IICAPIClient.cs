//----------------------
using Newtonsoft.Json;
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace ExchangeSetApiClient
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class IICAPIClient 
    {
#pragma warning disable 8618
        private string _baseUrl;
#pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings, true);
        private Newtonsoft.Json.JsonSerializerSettings _instanceSettings;

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public Client(System.Net.Http.HttpClient httpClient)
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "http://13.42.127.199:8080/xchg-7.1/v7.1/";
            _httpClient = httpClient;
            Initialize();
        }

        private static Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Add content to an exchange set
        /// </summary>
        /// <remarks>
        /// add content to an exchange set. Type is auto-detected. supports single dataset, supporting file (with certain extensions), folder and pre-existing exchange set (if CATALOG.XML is the filename). Content is added and the CATALOG.XML updated.
        /// </remarks>
        /// <param name="workspaceID">the name of the workspace the exchange set is located in.</param>
        /// <param name="exchangeSetID">the name of the exchange set. The name given to the exchange set when it was created.</param>
        /// <param name="resourceLocation">server location of content to add - must be a valid location</param>
        /// <param name="authkey">A valid authorisation key. To use a locked exchange set a valid locking code must be appended to the key separated using an underscore, e.g. "921038qw0_23490823"</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> AddContentAsync(string workspaceID, string exchangeSetID, string resourceLocation, string authkey)
        {
            return AddContentAsync(workspaceID, exchangeSetID, resourceLocation, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Add content to an exchange set
        /// </summary>
        /// <remarks>
        /// add content to an exchange set. Type is auto-detected. supports single dataset, supporting file (with certain extensions), folder and pre-existing exchange set (if CATALOG.XML is the filename). Content is added and the CATALOG.XML updated.
        /// </remarks>
        /// <param name="workspaceID">the name of the workspace the exchange set is located in.</param>
        /// <param name="exchangeSetID">the name of the exchange set. The name given to the exchange set when it was created.</param>
        /// <param name="resourceLocation">server location of content to add - must be a valid location</param>
        /// <param name="authkey">A valid authorisation key. To use a locked exchange set a valid locking code must be appended to the key separated using an underscore, e.g. "921038qw0_23490823"</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> AddContentAsync(string workspaceID, string exchangeSetID, string resourceLocation, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (resourceLocation == null)
                throw new System.ArgumentNullException("resourceLocation");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "addContent/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("addContent/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("resourceLocation")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(resourceLocation, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (authkey != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("exchange set or workspace not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("not authorised, permissions or locked exchange set", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create a new exchange set
        /// </summary>
        /// <remarks>
        /// create a new exchange set in the specified workspace. This method also locks the newly created exchange set and returns the locking code. This locking code must be appended to the authorisation key (for the workspace) for any calls which need write access to an exchange set. When the exchange set is finished then it should be unlocked using the appropriate API call.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> AddExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey)
        {
            return AddExchangeSetAsync(workspaceID, exchangeSetID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create a new exchange set
        /// </summary>
        /// <remarks>
        /// create a new exchange set in the specified workspace. This method also locks the newly created exchange set and returns the locking code. This locking code must be appended to the authorisation key (for the workspace) for any calls which need write access to an exchange set. When the exchange set is finished then it should be unlocked using the appropriate API call.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> AddExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "addExchangeSet/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("addExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// add a resource to a workspace
        /// </summary>
        /// <remarks>
        /// Add a supporting resource to the workspace, e.g signing keys, certificates, encryption keys. This enables them to be used by API calls when making exchange sets. Note that names are encoded with a prefix character (this makes it easy to differentiate them as they are encrypted by default), the name of the resource to refer to is returned with the API call. Note that this content is not validated when uploaded and encrypted so any errors may only be picked up when they are used. For formats refer to documntation.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="contentType">content type</param>
        /// <param name="authkey">authorisationkey</param>
        /// <param name="resourceName">supporting resource name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> AddresourceAsync(string workspaceID, ContentType contentType, string authkey, string resourceName, FileParameter resourcedata)
        {
            return AddresourceAsync(workspaceID, contentType, authkey, resourceName, resourcedata, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// add a resource to a workspace
        /// </summary>
        /// <remarks>
        /// Add a supporting resource to the workspace, e.g signing keys, certificates, encryption keys. This enables them to be used by API calls when making exchange sets. Note that names are encoded with a prefix character (this makes it easy to differentiate them as they are encrypted by default), the name of the resource to refer to is returned with the API call. Note that this content is not validated when uploaded and encrypted so any errors may only be picked up when they are used. For formats refer to documntation.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="contentType">content type</param>
        /// <param name="authkey">authorisationkey</param>
        /// <param name="resourceName">supporting resource name</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> AddresourceAsync(string workspaceID, ContentType contentType, string authkey, string resourceName, FileParameter resourcedata, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (contentType == null)
                throw new System.ArgumentNullException("contentType");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);

                    if (resourcedata != null)
                    {
                        var content_resourcedata_ = new System.Net.Http.StreamContent(resourcedata.Data);
                        if (!string.IsNullOrEmpty(resourcedata.ContentType))
                            content_resourcedata_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(resourcedata.ContentType);
                        content_.Add(content_resourcedata_, "resourcedata", resourcedata.FileName ?? "resourcedata");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "addResource/{workspaceID}"
                    urlBuilder_.Append("addResource/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("contentType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(contentType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (resourceName != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("resourceName")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(resourceName, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Add an existing workspace resource to an exchange set
        /// </summary>
        /// <remarks>
        /// add an existing supporting resource to an exchange set, e.g. Catalogue or certificate. Adding them to the exchange set includes those catalogues with the exchange set content.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="resourceName">supporting resource name</param>
        /// <param name="contentType">content type</param>
        /// <param name="authkey">authorisation key</param>
        /// <param name="productName">Product name (if applicable)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> AddResourceContentAsync(string workspaceID, string exchangeSetID, string resourceName, ContentType2 contentType, string authkey, string productName)
        {
            return AddResourceContentAsync(workspaceID, exchangeSetID, resourceName, contentType, authkey, productName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Add an existing workspace resource to an exchange set
        /// </summary>
        /// <remarks>
        /// add an existing supporting resource to an exchange set, e.g. Catalogue or certificate. Adding them to the exchange set includes those catalogues with the exchange set content.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="resourceName">supporting resource name</param>
        /// <param name="contentType">content type</param>
        /// <param name="authkey">authorisation key</param>
        /// <param name="productName">Product name (if applicable)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> AddResourceContentAsync(string workspaceID, string exchangeSetID, string resourceName, ContentType2 contentType, string authkey, string productName, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (resourceName == null)
                throw new System.ArgumentNullException("resourceName");

            if (contentType == null)
                throw new System.ArgumentNullException("contentType");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "addResource/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("addResource/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("resourceName")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(resourceName, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("contentType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(contentType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (productName != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("productName")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(productName, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// add a new workspace under the filesystem root on the server
        /// </summary>
        /// <remarks>
        /// add a new workspace under the filesystem root on the server. this allows the workspace to be used to contain exchange sets. The authorisation key given is the one to be used to encrypt all resources and must be used to access the workspace in future.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="authkey">key bytes, will be used to encrypt all resources in the workspace</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> AddworkspaceAsync(string workspaceID, string authkey)
        {
            return AddworkspaceAsync(workspaceID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// add a new workspace under the filesystem root on the server
        /// </summary>
        /// <remarks>
        /// add a new workspace under the filesystem root on the server. this allows the workspace to be used to contain exchange sets. The authorisation key given is the one to be used to encrypt all resources and must be used to access the workspace in future.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="authkey">key bytes, will be used to encrypt all resources in the workspace</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> AddworkspaceAsync(string workspaceID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "addWorkspace/{workspaceID}"
                    urlBuilder_.Append("addWorkspace/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete an element of an exchange set
        /// </summary>
        /// <remarks>
        /// Delete a named entry in the exchange set.
        /// </remarks>
        /// <param name="workspaceID">name of workspace the exchange set is in</param>
        /// <param name="exchangeSetID">REF</param>
        /// <param name="authkey">REF</param>
        /// <param name="fileName">filenames are unique in an exchange set. resources matching this name are deleted. [add * to delete everything?]</param>
        /// <param name="path">Qualify deletion with a path. ALthough filenames are unique, they can appear in multiple places. Default is to delete everything, this option restricts the deletion to just the location specified.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> DelContentAsync(string workspaceID, string exchangeSetID, string authkey, string fileName, string path)
        {
            return DelContentAsync(workspaceID, exchangeSetID, authkey, fileName, path, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete an element of an exchange set
        /// </summary>
        /// <remarks>
        /// Delete a named entry in the exchange set.
        /// </remarks>
        /// <param name="workspaceID">name of workspace the exchange set is in</param>
        /// <param name="exchangeSetID">REF</param>
        /// <param name="authkey">REF</param>
        /// <param name="fileName">filenames are unique in an exchange set. resources matching this name are deleted. [add * to delete everything?]</param>
        /// <param name="path">Qualify deletion with a path. ALthough filenames are unique, they can appear in multiple places. Default is to delete everything, this option restricts the deletion to just the location specified.</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> DelContentAsync(string workspaceID, string exchangeSetID, string authkey, string fileName, string path, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (fileName == null)
                throw new System.ArgumentNullException("fileName");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            if (path == null)
                throw new System.ArgumentNullException("path");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "delContent/{workspaceID}/{exchangeSetID}/{fileName}"
                    urlBuilder_.Append("delContent/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(fileName, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("path")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(path, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete an entire exchange set
        /// </summary>
        /// <remarks>
        /// Permanently delete exchange set from a workspace.
        /// </remarks>
        /// <param name="workspaceID">name of workspace the exchange set is in</param>
        /// <param name="exchangeSetID">REF</param>
        /// <param name="authkey">REF</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> DelExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey)
        {
            return DelExchangeSetAsync(workspaceID, exchangeSetID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete an entire exchange set
        /// </summary>
        /// <remarks>
        /// Permanently delete exchange set from a workspace.
        /// </remarks>
        /// <param name="workspaceID">name of workspace the exchange set is in</param>
        /// <param name="exchangeSetID">REF</param>
        /// <param name="authkey">REF</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> DelExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "delExchangeSet/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("delExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// test endpoint
        /// </summary>
        /// <remarks>
        /// various uses - test only.
        /// </remarks>
        /// <param name="arg">ref</param>
        /// <param name="authkey">Authorisation Key (or name of exchange set to delete)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> TestingAsync(string arg, string authkey)
        {
            return TestingAsync(arg, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// test endpoint
        /// </summary>
        /// <remarks>
        /// various uses - test only.
        /// </remarks>
        /// <param name="arg">ref</param>
        /// <param name="authkey">Authorisation Key (or name of exchange set to delete)</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> TestingAsync(string arg, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (arg == null)
                throw new System.ArgumentNullException("arg");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "dev"
                    urlBuilder_.Append("dev");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("arg")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(arg, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Message>("error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Package an exchange set on the server
        /// </summary>
        /// <remarks>
        /// zips an exchange set into a predefined location on the server. Also returns exchange set as a zip archive for onward distribution.
        /// </remarks>
        /// <param name="workspaceID">the workspace id</param>
        /// <param name="exchangeSetID">identifer of the exchange set to be packaged</param>
        /// <param name="authkey">REF</param>
        /// <param name="destination">Save to destination folder on server as well</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> PackageexchangesetAsync(string workspaceID, string exchangeSetID, string authkey, string destination)
        {
            return PackageexchangesetAsync(workspaceID, exchangeSetID, authkey, destination, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Package an exchange set on the server
        /// </summary>
        /// <remarks>
        /// zips an exchange set into a predefined location on the server. Also returns exchange set as a zip archive for onward distribution.
        /// </remarks>
        /// <param name="workspaceID">the workspace id</param>
        /// <param name="exchangeSetID">identifer of the exchange set to be packaged</param>
        /// <param name="authkey">REF</param>
        /// <param name="destination">Save to destination folder on server as well</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> PackageexchangesetAsync(string workspaceID, string exchangeSetID, string authkey, string destination, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/zip"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "extractExchangeSet/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("extractExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (destination != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("destination")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(destination, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Unlock an exchange set.
        /// </summary>
        /// <remarks>
        /// unlocks a previously locked exchange set. This allows other processes to acccess it (locking it again).
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey with lock key appended with a "_" character. If no lock key is given then the force parameter must be used to forcibly unlock an exchange set.</param>
        /// <returns>successful lock. Returns lock key. this must be appended to the authorisation key (with a _ character) in subsequent operations to ensure concurrent accress.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Lock> FreeExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, bool? force)
        {
            return FreeExchangeSetAsync(workspaceID, exchangeSetID, authkey, force, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Unlock an exchange set.
        /// </summary>
        /// <remarks>
        /// unlocks a previously locked exchange set. This allows other processes to acccess it (locking it again).
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey with lock key appended with a "_" character. If no lock key is given then the force parameter must be used to forcibly unlock an exchange set.</param>
        /// <returns>successful lock. Returns lock key. this must be appended to the authorisation key (with a _ character) in subsequent operations to ensure concurrent accress.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Lock> FreeExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, bool? force, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "freeExchangeSet/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("freeExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (force != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("force")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Lock>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Message>("error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List all exchange sets for a particular workspace
        /// </summary>
        /// <remarks>
        /// List all exchange sets in the workspace. No estimates of any content are made.
        /// </remarks>
        /// <param name="workspaceID">REF</param>
        /// <param name="authkey">REF</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> ListExchangeSetAsync(string workspaceID, string authkey)
        {
            return ListExchangeSetAsync(workspaceID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List all exchange sets for a particular workspace
        /// </summary>
        /// <remarks>
        /// List all exchange sets in the workspace. No estimates of any content are made.
        /// </remarks>
        /// <param name="workspaceID">REF</param>
        /// <param name="authkey">REF</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> ListExchangeSetAsync(string workspaceID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "listExchangeSet/{workspaceID}"
                    urlBuilder_.Append("listExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (authkey != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("workspace not fond", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List all resources avaialable for the specified workspace
        /// </summary>
        /// <remarks>
        /// show all resources available to choose from. this includes all static data used as defaults for each created exchange set, and default selectors for keys and certificates. If static resources need to be changed then another API call can be used.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> ListresourceAsync(string workspaceID, string authkey)
        {
            return ListresourceAsync(workspaceID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List all resources avaialable for the specified workspace
        /// </summary>
        /// <remarks>
        /// show all resources available to choose from. this includes all static data used as defaults for each created exchange set, and default selectors for keys and certificates. If static resources need to be changed then another API call can be used.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> ListresourceAsync(string workspaceID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "listResource/{workspaceID}"
                    urlBuilder_.Append("listResource/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// List all available workspaces
        /// </summary>
        /// <remarks>
        /// list all workspaces
        /// </remarks>
        /// <param name="authkey">another message</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> ListWorkspaceAsync(string authkey)
        {
            return ListWorkspaceAsync(authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// List all available workspaces
        /// </summary>
        /// <remarks>
        /// list all workspaces
        /// </remarks>
        /// <param name="authkey">another message</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> ListWorkspaceAsync(string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "listWorkspace"
                    urlBuilder_.Append("listWorkspace");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Request a lock on an exchange set.
        /// </summary>
        /// <remarks>
        /// Attempt to lock (or query a locked) exchange set.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>successful new  lock. Returns lock key. this must be appended to the authorisation key (with "_" char) in subsequent operations to ensure concurrent accress.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Lock> LockExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey)
        {
            return LockExchangeSetAsync(workspaceID, exchangeSetID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Request a lock on an exchange set.
        /// </summary>
        /// <remarks>
        /// Attempt to lock (or query a locked) exchange set.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>successful new  lock. Returns lock key. this must be appended to the authorisation key (with "_" char) in subsequent operations to ensure concurrent accress.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Lock> LockExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "lockExchangeSet/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("lockExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Lock>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Lock>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Message>("error(s)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// get lock informaton information for an exchange set.
        /// </summary>
        /// <remarks>
        /// Query whether an exchange set is locked or not.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>Successful new  lock. Returns lock key. this must be appended to the authorisation key (with "_" char) in subsequent operations to ensure concurrent accress.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Lock> LockInfoAsync(string workspaceID, string exchangeSetID, string authkey)
        {
            return LockInfoAsync(workspaceID, exchangeSetID, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// get lock informaton information for an exchange set.
        /// </summary>
        /// <remarks>
        /// Query whether an exchange set is locked or not.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">authorisationkey</param>
        /// <returns>Successful new  lock. Returns lock key. this must be appended to the authorisation key (with "_" char) in subsequent operations to ensure concurrent accress.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Lock> LockInfoAsync(string workspaceID, string exchangeSetID, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "lockInfo/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("lockInfo/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Lock>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Lock>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Message>("Error(s). message text contains any useful info.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Modify workspace static data defaults
        /// </summary>
        /// <remarks>
        /// modify default data in a workspace, e.g. default keys, certificates or encryption keys.
        /// </remarks>
        /// <param name="workspaceID">REF</param>
        /// <param name="authkey">REF</param>
        /// <param name="key">field to change</param>
        /// <param name="value">value to change it to</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> ModWorkspaceAsync(string workspaceID, string authkey, string key, string value)
        {
            return ModWorkspaceAsync(workspaceID, authkey, key, value, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Modify workspace static data defaults
        /// </summary>
        /// <remarks>
        /// modify default data in a workspace, e.g. default keys, certificates or encryption keys.
        /// </remarks>
        /// <param name="workspaceID">REF</param>
        /// <param name="authkey">REF</param>
        /// <param name="key">field to change</param>
        /// <param name="value">value to change it to</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> ModWorkspaceAsync(string workspaceID, string authkey, string key, string value, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "modWorkspace/{workspaceID}"
                    urlBuilder_.Append("modWorkspace/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (authkey != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (value != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("value")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(value, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Sign an exchange set element
        /// </summary>
        /// <remarks>
        /// digitally sign (or re-sign) an element of the exchange set. If a signature exists it will be replaced.
        /// </remarks>
        /// <param name="workspaceID">REF</param>
        /// <param name="exchangeSetID">REF</param>
        /// <param name="fileName">REF</param>
        /// <param name="contentType">Type of signature required</param>
        /// <param name="authkey">REF</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> SignContentAsync(string workspaceID, string exchangeSetID, string fileName, ContentType3? contentType, string authkey)
        {
            return SignContentAsync(workspaceID, exchangeSetID, fileName, contentType, authkey, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sign an exchange set element
        /// </summary>
        /// <remarks>
        /// digitally sign (or re-sign) an element of the exchange set. If a signature exists it will be replaced.
        /// </remarks>
        /// <param name="workspaceID">REF</param>
        /// <param name="exchangeSetID">REF</param>
        /// <param name="fileName">REF</param>
        /// <param name="contentType">Type of signature required</param>
        /// <param name="authkey">REF</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> SignContentAsync(string workspaceID, string exchangeSetID, string fileName, ContentType3? contentType, string authkey, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (fileName == null)
                throw new System.ArgumentNullException("fileName");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "signContent/{workspaceID}/{exchangeSetID}/{fileName}"
                    urlBuilder_.Append("signContent/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(fileName, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (contentType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("contentType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(contentType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (authkey != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Sign exchange set (produces a CATALOG.SIGN)
        /// </summary>
        /// <remarks>
        /// Digitally sign a given exchange set producing a valid CATALOG.SIGN. If the workspace default signing keys are to be overriden then they are specified in this call.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">REF</param>
        /// <param name="privateKey">name of private key to use</param>
        /// <param name="certificate">name of corresponding certificate to use</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Message> SignExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, string privateKey, string certificate)
        {
            return SignExchangeSetAsync(workspaceID, exchangeSetID, authkey, privateKey, certificate, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sign exchange set (produces a CATALOG.SIGN)
        /// </summary>
        /// <remarks>
        /// Digitally sign a given exchange set producing a valid CATALOG.SIGN. If the workspace default signing keys are to be overriden then they are specified in this call.
        /// </remarks>
        /// <param name="workspaceID">message</param>
        /// <param name="exchangeSetID">message</param>
        /// <param name="authkey">REF</param>
        /// <param name="privateKey">name of private key to use</param>
        /// <param name="certificate">name of corresponding certificate to use</param>
        /// <returns>successful operation</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Message> SignExchangeSetAsync(string workspaceID, string exchangeSetID, string authkey, string privateKey, string certificate, System.Threading.CancellationToken cancellationToken)
        {
            if (workspaceID == null)
                throw new System.ArgumentNullException("workspaceID");

            if (exchangeSetID == null)
                throw new System.ArgumentNullException("exchangeSetID");

            if (authkey == null)
                throw new System.ArgumentNullException("authkey");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "signExchangeSet/{workspaceID}/{exchangeSetID}"
                    urlBuilder_.Append("signExchangeSet/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(workspaceID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(exchangeSetID, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("authkey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(authkey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (privateKey != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("privateKey")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(privateKey, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (certificate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("certificate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(certificate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Message>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Message
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message1 { get; set; }

        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Code { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Lock
    {
        [Newtonsoft.Json.JsonProperty("lockID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LockID { get; set; }

        [Newtonsoft.Json.JsonProperty("datetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Datetime { get; set; }

    }

    /// <summary>
    /// content type
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContentType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Public Key")]
        Public_Key = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Private Key")]
        Private_Key = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Certificate")]
        Certificate = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Encryption Keys")]
        Encryption_Keys = 3,

    }

    /// <summary>
    /// content type
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContentType2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Portrayal Catalogue")]
        Portrayal_Catalogue = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Feature Catalogue")]
        Feature_Catalogue = 1,

    }

    /// <summary>
    /// Type of signature required
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContentType3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DataSignature")]
        DataSignature = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AdditionalDataSignature")]
        AdditionalDataSignature = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SignatureOnSignature")]
        SignatureOnSignature = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this(data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this(data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 108
#pragma warning restore 114
#pragma warning restore 472
#pragma warning restore 612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625